let callbacks = {
  return: \x ->
    \callback -> callback x
  bind: \action1 f ->
    \callback ->
      let callback1 = \x ->
        let action2 = f x
        action2 callback
      action1 callback1
}
let makeCallback = \f ->
    \callback ->
      f ()
      callMaybe callback
let callMaybe callback = if (callback != null) then callback () else null

let fd d = makeCallback (\() -> turtle.fd d)
let lt a = makeCallback (\() -> turtle.lt a)
let rt a = makeCallback(\() -> turtle.rt a)
let pendown = makeCallback(\() -> turtle.pendown ())
let penup = makeCallback(\() -> turtle.penup ())
let clear = makeCallback(\() -> turtle.clear ())
let wait seconds = (\callback -> setTimeout callback (seconds * 1000))
let say text = makeCallback (\() -> speak text)

// Action sequencing / repeat utils

let sequence fs =
  let sequence_ fs depth = \callback ->
    if empty fs then
      callMaybe callback
    else
      let next () = (sequence_ (tail fs) (depth + 1)) callback
      let schedule () = setTimeout next 0
      // avoid stack overflow with ugly hack
      (head fs) (if depth > 100 then schedule else next)
  sequence_ fs 0
let repeat n f = sequence (times n f)
